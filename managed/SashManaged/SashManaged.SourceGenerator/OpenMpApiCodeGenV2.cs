using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SashManaged.SourceGenerator.Marshalling;

namespace SashManaged.SourceGenerator;

[Generator]
public class OpenMpApiCodeGenV2 : IIncrementalGenerator
{
    private const string COMMENT_SETUP = "// Setup - Perform required setup.";
    private const string COMMENT_MARSHAL = "// Marshal - Convert managed data to native data.";
    private const string COMMENT_PINNED_MARSHAL = "// PinnedMarshal - Convert managed data to native data that requires the managed data to be pinned.";
    private const string COMMENT_NOTIFY = "// NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.";
    private const string COMMENT_UNMARSHAL_CAPTURE =
        "// UnmarshalCapture - Capture the native data into marshaller instances in case conversion to managed data throws an exception.";
    private const string COMMENT_UNMARSHAL = "// Unmarshal - Convert native data to managed data.";
    private const string COMMENT_CLEANUP_CALLEE = "// CleanupCalleeAllocated - Perform cleanup of callee allocated resources.";
    private const string COMMENT_CLEANUP_CALLER = "// CleanupCallerAllocated - Perform cleanup of caller allocated resources.";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedStructs = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.ApiAttribute2FQN, 
                static (s, _) => s is StructDeclarationSyntax str && str.IsPartial(), 
                static(ctx, ct) => GetStructDeclaration(ctx, ct))
            .Where(x => x is not null);

        context.RegisterSourceOutput(attributedStructs, (ctx, info) =>
        {
            var node = info.Node;
            var symbol = info.Symbol;

            var structDeclaration = StructDeclaration(node.Identifier)
                .WithModifiers(node.Modifiers)
                .WithMembers(GenerateStructMembers(info))
                .WithBaseList(
                    BaseList(
                        SeparatedList<BaseTypeSyntax>(
                            GetBaseTypes(info))))
                .WithAttributeLists(
                    List(
                        new []{
                            AttributeFactory.GeneratedCode(),
                            AttributeFactory.SkipLocalsInit()
                        }));

            var unit = CompilationUnit()
                .AddMembers(NamespaceDeclaration(ParseName(symbol.ContainingNamespace.ToDisplayString()))
                    .AddMembers(structDeclaration))
                .WithLeadingTrivia(Comment("// <auto-generated />"),
                    Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), SingletonSeparatedList<ExpressionSyntax>(IdentifierName("CS8500")), true)));

            var sourceText = unit.NormalizeWhitespace(elasticTrivia: true)
                .GetText(Encoding.UTF8);

            ctx.AddSource($"{symbol.Name}.g.cs", sourceText);
        });
    }

    private static IEnumerable<SimpleBaseTypeSyntax> GetBaseTypes(StructStubGenerationContext ctx)
    {
        return ctx.ImplementingTypes.Select(x => 
                SimpleBaseType(
                    GenericName(
                            Identifier($"global::{Constants.IEquatableFQN}"))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName($"global::{x.ToDisplayString()}"))))))
            .Concat([
                SimpleBaseType(
                    GenericName(
                            Identifier($"global::{Constants.IEquatableFQN}"))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name))))),
                SimpleBaseType(
                    IdentifierName($"global::{Constants.PointerFQN}"))
            ]);
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateStructMembers(StructStubGenerationContext ctx)
    {
        return List(
            GenerateCommonStructMembers(ctx)
                .Concat(GenerateImplementingTypeMembers(ctx))
                .Concat(
                    ctx.Methods.Select(GenerateMethod)
                        .Where(x => x != null)));
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateImplementingTypeMembers(StructStubGenerationContext ctx)
    {
        var result = List<MemberDeclarationSyntax>();

        foreach (var implementingType in ctx.ImplementingTypes)
        {
            var implementingMethods = implementingType.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(x => !x.IsStatic && x.MethodKind == MethodKind.Ordinary && x.Name != "Equals");

            foreach (var implementingMethod in implementingMethods)
            {
                var method = MethodDeclaration(
                        ToTypeSyntax(
                            implementingMethod.ReturnType, 
                            implementingMethod.ReturnsByRef, 
                            implementingMethod.ReturnsByRefReadonly), 
                        implementingMethod.Name)
                    .WithParameterList(
                        ToParameterListSyntax(implementingMethod.Parameters));

                var typeStr = $"global::{implementingType.ToDisplayString()}";

                var invocation =  
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            ObjectCreationExpression(
                                    IdentifierName(typeStr))
                                .WithArgumentList(
                                    ArgumentList(
                                        SingletonSeparatedList(
                                            Argument(
                                                IdentifierName("_handle"))))),
                            IdentifierName(implementingMethod.Name)))
                        .WithArgumentList(
                            ArgumentList(
                                SeparatedList(
                                    implementingMethod.Parameters.Select(GetArgumentForParameter))));

                if (implementingMethod.ReturnsVoid)
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ExpressionStatement(invocation))));
                }
                else if (implementingMethod.ReturnsByRef || implementingMethod.ReturnsByRefReadonly)
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ReturnStatement(
                                    RefExpression(invocation)))));
                }
                else
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ReturnStatement(invocation))));
                }

                result = result.Add(method);
            }
        }

        return result;
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateCommonStructMembers(StructStubGenerationContext ctx)
    {
        // private readonly field _handle;
        var nintType = ParseTypeName("nint");
        yield return FieldDeclaration(VariableDeclaration(nintType, SingletonSeparatedList(VariableDeclarator("_handle"))))
            .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

        // .ctor(nint handle)
        yield return ConstructorDeclaration(Identifier(ctx.Symbol.Name))
            .WithParameterList(ParameterList(
                SingletonSeparatedList(
                Parameter(Identifier("handle")).WithType(nintType)
                )))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(
                SingletonList(
                    ExpressionStatement(
                        AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression, 
                            IdentifierName("_handle"),
                            IdentifierName("handle"))))));

        // public nint Handle => _handle;
        yield return PropertyDeclaration(nintType, "Handle")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithExpressionBody(ArrowExpressionClause(IdentifierName("_handle")))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

        // public override bool Equals(object obj)
        yield return MethodDeclaration(
            PredefinedType(Token(SyntaxKind.BoolKeyword)),
            Identifier("Equals"))
        .WithModifiers(
            TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.OverrideKeyword)
            ))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier("obj"))
                    .WithType(
                            PredefinedType(Token(SyntaxKind.ObjectKeyword))))))
        .WithBody(
            Block(
                IfStatement(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(
                            IdentifierName("obj"),
                            ConstantPattern(
                                LiteralExpression(SyntaxKind.NullLiteralExpression))),
                        BinaryExpression(
                            SyntaxKind.EqualsExpression,
                            IdentifierName("Handle"),
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName("nint"),
                                IdentifierName("Zero")))),
                    Block(
                        SingletonList<StatementSyntax>(
                            ReturnStatement(
                                LiteralExpression(SyntaxKind.TrueLiteralExpression))))),
                ReturnStatement(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(
                            IdentifierName("obj"),
                            DeclarationPattern(
                                IdentifierName($"global::{Constants.PointerFQN}"),
                                SingleVariableDesignation(
                                    Identifier("other")))),
                        InvocationExpression(
                            IdentifierName("Equals"))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(IdentifierName("other")))))))));

        // public bool Equals(IPointer other)
        yield return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.BoolKeyword)),
                Identifier("Equals"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(Identifier("other"))
                            .WithType(IdentifierName("IPointer")))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            BinaryExpression(
                                SyntaxKind.EqualsExpression,
                                IdentifierName("_handle"),
                                ParenthesizedExpression(
                                    BinaryExpression(
                                        SyntaxKind.CoalesceExpression,
                                        ConditionalAccessExpression(
                                            IdentifierName("other"),
                                            MemberBindingExpression(
                                                IdentifierName("Handle"))),
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("nint"),
                                            IdentifierName("Zero")))))))));

        // public override int GetHashCode()
        yield return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.IntKeyword)),
                Identifier("GetHashCode"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.OverrideKeyword)
                ))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("_handle"),
                                    IdentifierName("GetHashCode")))))));

        //type == object
        yield return
            CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                CreateLhsEqualsRhs(false)
            );

        // type != object
        yield return
            CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                CreateLhsEqualsRhs(true)
            );

        // object == type
        yield return
            CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                IdentifierName(ctx.Symbol.Name), 
                CreateRhsEqualsLhs(false)
            );
        
        // object != type
        yield return
            CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                IdentifierName(ctx.Symbol.Name), 
                CreateRhsEqualsLhs(true)
            );

        // bool Equals(type other)
        yield return CreateEqualsMethod(ctx.Symbol.Name);
        
        //type == type
        yield return
            CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                IdentifierName(ctx.Symbol.Name), 
                CreateLhsEqualsRhs(false)
            );

        // type != type
        yield return
            CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                IdentifierName(ctx.Symbol.Name), 
                CreateLhsEqualsRhs(true)
            );

        // TODO members for inheritance with depth > 1
        foreach (var type in ctx.ImplementingTypes)
        {
            var implType = $"global::{type.ToDisplayString()}";

            // public bool Equals(impl other)
            yield return CreateEqualsMethod(implType);

            //type == impl
            yield return
                CreateOperator(
                    SyntaxKind.EqualsEqualsToken,
                    IdentifierName(ctx.Symbol.Name), 
                    IdentifierName(implType), 
                    CreateLhsEqualsRhs(false)
                );

            // type != impl
            yield return
                CreateOperator(
                    SyntaxKind.ExclamationEqualsToken,
                    IdentifierName(ctx.Symbol.Name), 
                    IdentifierName(implType), 
                    CreateLhsEqualsRhs(true)
                );

            // impl == type
            yield return
                CreateOperator(
                    SyntaxKind.EqualsEqualsToken,
                    IdentifierName(implType), 
                    IdentifierName(ctx.Symbol.Name), 
                    CreateRhsEqualsLhs(false)
                );
        
            // impl != type
            yield return
                CreateOperator(
                    SyntaxKind.ExclamationEqualsToken,
                    IdentifierName(implType), 
                    IdentifierName(ctx.Symbol.Name), 
                    CreateRhsEqualsLhs(true)
                );

            yield return ConversionOperatorDeclaration(
                Token(SyntaxKind.ImplicitKeyword),
                IdentifierName("BaseTest"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                            Identifier("value"))
                        .WithType(
                            IdentifierName("TestV2")))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            ObjectCreationExpression(
                                IdentifierName(implType))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName("value"),
                                                IdentifierName("Handle"))))))))));

            yield return ConversionOperatorDeclaration(
                Token(SyntaxKind.ExplicitKeyword),
                IdentifierName("TestV2"))
            .WithModifiers(
                TokenList(Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                            Identifier("value"))
                        .WithType(
                            IdentifierName(implType)))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            ObjectCreationExpression(
                                IdentifierName("TestV2"))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName("value"),
                                                IdentifierName("Handle"))))))))));
        }
    }

    private static MethodDeclarationSyntax CreateEqualsMethod(string typeName)
    {
        return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.BoolKeyword)),
                Identifier("Equals"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(Identifier("other"))
                            .WithType(IdentifierName(typeName)))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            BinaryExpression(
                                SyntaxKind.EqualsExpression,
                                IdentifierName("Handle"),
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("other"),
                                    IdentifierName("Handle")))))));
    }

    private static OperatorDeclarationSyntax CreateOperator(SyntaxKind operatorToken, TypeSyntax lhsType, TypeSyntax rhsType, BlockSyntax block)
    {
        return OperatorDeclaration(
                PredefinedType(
                    Token(SyntaxKind.BoolKeyword)),
                Token(operatorToken))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)
                ))
            .WithParameterList(
                ParameterList(
                    SeparatedList(new []{
                        Parameter(Identifier("lhs"))
                            .WithType(lhsType),
                        Parameter(Identifier("rhs"))
                            .WithType(rhsType)
                    })))
            .WithBody(block
                );
    }

    private static BlockSyntax CreateLhsEqualsRhs(bool logicalNot)
    {
        return CreateThisEqualsThat(logicalNot, "lhs", "rhs");
    }
    
    private static BlockSyntax CreateRhsEqualsLhs(bool logicalNot)
    {
        return CreateThisEqualsThat(logicalNot, "rhs", "lhs");
    }

    private static BlockSyntax CreateThisEqualsThat(bool logicalNot, string @this, string that)
    {
        var invocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(@this),
                    IdentifierName("Equals")))
            .WithArgumentList(
                ArgumentList(
                    SingletonSeparatedList(
                        Argument(
                            IdentifierName(that)))));

        if (logicalNot)
        {
            return Block(
                SingletonList<StatementSyntax>(
                    ReturnStatement(
                        PrefixUnaryExpression(
                            SyntaxKind.LogicalNotExpression,
                            invocation))));
        }

        return Block(
            SingletonList<StatementSyntax>(
                ReturnStatement(invocation)));
    }

    private static MemberDeclarationSyntax GenerateMethod(MethodStubGenerationContext ctx)
    {
        var invocation = CreateInvocation(ctx);
        
        // Extern P/Invoke
        var externReturnType = ctx.ReturnMarshallerShape?.GetNativeType() ?? 
                               ToTypeSyntax(ctx.Symbol.ReturnType, ctx.Symbol.ReturnsByRef, ctx.Symbol.ReturnsByRefReadonly);

        var externFunction = CreateExternFunction(ctx, externReturnType);

        invocation = invocation.WithStatements(invocation.Statements.Add(externFunction));
     
        return MethodDeclaration(ToReturnTypeSyntax(ctx.Symbol), ctx.Declaration.Identifier)
            .WithModifiers(ctx.Declaration.Modifiers)
            .WithParameterList(ToParameterListSyntax(ctx.Symbol.Parameters))
            .WithBody(invocation);
    }

    private static BlockSyntax CreateInvocation(MethodStubGenerationContext ctx)
    {
        return ctx.RequiresMarshalling 
            ? CreateInvocationWithMarshalling(ctx)
            : CreateInvocationWithoutMarshalling(ctx);
    }

    private static ArgumentSyntax GetArgumentForParameter(ParameterStubGenerationContext ctx)
    {
        var identifier = ctx.Symbol.Name;
        if (ctx.MarshallerShape != null)
        {
            identifier = $"__{identifier}_native";
        }

        return WithParameterRefKind(Argument(IdentifierName(identifier)), ctx.Symbol);
    }

    private static ArgumentSyntax GetArgumentForParameter(IParameterSymbol symbol)
    {
        return WithParameterRefKind(Argument(IdentifierName(symbol.Name)), symbol);
    }

    private static ArgumentSyntax WithParameterRefKind(ArgumentSyntax argument, IParameterSymbol parameter)
    {
        switch (parameter.RefKind)
        {
            case RefKind.Ref:
                return argument.WithRefKindKeyword(Token(SyntaxKind.RefKeyword));
            case RefKind.Out:
                return argument.WithRefKindKeyword(Token(SyntaxKind.OutKeyword));
            default:
                return argument;
        }
    }

    private static BlockSyntax CreateInvocationWithoutMarshalling(MethodStubGenerationContext ctx)
    {
        ExpressionSyntax invoke = InvocationExpression(IdentifierName("__PInvoke"))
            .WithArgumentList(
                ArgumentList(
                    SingletonSeparatedList(Argument(IdentifierName("_handle")))
                        .AddRange(
                            ctx.Parameters.Select(GetArgumentForParameter)
                        )
                )
            );

        // No marshalling required, call __PInvoke and return
        if (ctx.Symbol.ReturnsVoid)
        {
            return Block(ExpressionStatement(invoke));
        }
            
        if (ctx.Symbol.ReturnsByRef || ctx.Symbol.ReturnsByRefReadonly)
        {
            invoke = RefExpression(invoke);
        }

        return Block(ReturnStatement(invoke));
    }

    private static BlockSyntax CreateInvocationWithMarshalling(MethodStubGenerationContext ctx)
    {
        ExpressionSyntax invoke = 
            InvocationExpression(IdentifierName("__PInvoke"))
                .WithArgumentList(
                    ArgumentList(
                        SingletonSeparatedList(
                                Argument(IdentifierName("_handle")))
                            .AddRange(
                                ctx.Parameters.Select(GetArgumentForParameter))));
        
        if (!ctx.Symbol.ReturnsVoid)
        {
            invoke = 
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression, 
                    IdentifierName(ctx.ReturnMarshallerShape == null ? "__retVal" : "__retVal_native"), 
                    invoke);
        }

        // The generated method consists of the following content:
        //
        // LocalsInit - Generate locals for marshalled types and return value
        // Setup - Perform required setup.
        // try
        // {
        //   Marshal - Convert managed data to native data.
        //   {
        //     PinnedMarshal - Convert managed data to native data that requires the managed data to be pinned.
        //     p/invoke 
        //   }
        //   NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.
        //   UnmarshalCapture - Capture the native data into marshaller instances in case conversion to managed data throws an exception.
        //   Unmarshal - Convert native data to managed data.
        // }
        // finally
        // {
        //   if (invokeSuccess)
        //   {
        //      CleanupCalleeAllocated - Perform cleanup of callee allocated resources.
        //   }
        //   CleanupCallerAllocated - Perform cleanup of caller allocated resources.
        // }
        //
        // return: retVal
        //
        // NOTES:
        // - design doc: https://github.com/dotnet/runtime/blob/main/docs/design/libraries/LibraryImportGenerator/UserTypeMarshallingV2.md
        // - we're supporting Default, ManagedToUnmanagedIn, ManagedToUnmanagedOut, ManagedToUnmanagedRef
        // - not implementing element marshalling (arrays) at the moment.
        // - TODO: GetPinnableReference support
        // - TODO: marshaller shapes with guaranteed unmarshalling
        // - TODO: marshaller shape for stateful bidirectional 

        // collect all marshalling steps
        var setup = Step(ctx, COMMENT_SETUP, (p, m) => m.Setup(p), ctx.ReturnMarshallerShape?.Setup(null) ?? default);
        var marshal = Step(ctx, COMMENT_MARSHAL, (p, m) => m.Marshal(p), ctx.ReturnMarshallerShape?.Marshal(null) ?? default);
        var pinnedMarshal = Step(ctx, COMMENT_PINNED_MARSHAL, (p, m) => m.PinnedMarshal(p), ctx.ReturnMarshallerShape?.PinnedMarshal(null) ?? default);
        var notify = Step(ctx, COMMENT_NOTIFY, (p, m) => m.NotifyForSuccessfulInvoke(p), ctx.ReturnMarshallerShape?.NotifyForSuccessfulInvoke(null) ?? default);
        var unmarshalCapture = Step(ctx, COMMENT_UNMARSHAL_CAPTURE, (p, m) => m.UnmarshalCapture(p), ctx.ReturnMarshallerShape?.UnmarshalCapture(null) ?? default);
        var unmarshal = Step(ctx, COMMENT_UNMARSHAL, (p, m) => m.Unmarshal(p), ctx.ReturnMarshallerShape?.Unmarshal(null) ?? default);
        var cleanupCallee = Step(ctx, COMMENT_CLEANUP_CALLEE, (p, m) => m.CleanupCalleeAllocated(p), ctx.ReturnMarshallerShape?.CleanupCalleeAllocated(null) ?? default);
        var cleanupCaller = Step(ctx, COMMENT_CLEANUP_CALLER, (p, m) => m.CleanupCallerAllocated(p), ctx.ReturnMarshallerShape?.CleanupCallerAllocated(null) ?? default);
        
        // init locals
        var statements = Step(ctx, null, (p, m) => 
            SingletonList<StatementSyntax>(
                CreateLocalDeclarationWithDefaultValue(m.GetNativeType(), $"__{p.Name}_native")));

        if (!ctx.Symbol.ReturnsVoid)
        {
            var returnType = ToTypeSyntax(ctx.Symbol.ReturnType);
            statements = statements.Add(CreateLocalDeclarationWithDefaultValue(returnType, "__retVal"));
        }

        if (ctx.ReturnMarshallerShape != null)
        {
            var nativeType = ctx.ReturnMarshallerShape.GetNativeType();
            statements = statements.Add(CreateLocalDeclarationWithDefaultValue(nativeType, "__retVal_native"));
        }

        // if callee cleanup is required, we need to keep track of invocation success
        if (cleanupCallee.Count > 0)
        {
            
            statements = statements.Add(
                CreateLocalDeclarationWithDefaultValue(
                    PredefinedType(Token(SyntaxKind.BoolKeyword)), 
                    "__invokeSucceeded"));
        
            notify = notify.Insert(0, 
                ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression, 
                        IdentifierName("__invokeSucceeded"), 
                        LiteralExpression(SyntaxKind.TrueLiteralExpression))));
        
            cleanupCallee = SingletonList<StatementSyntax>(
                        IfStatement(IdentifierName("__invokeSucceeded"), 
                        Block(cleanupCallee)));
        }
        
        // wire up steps
        var finallyStatements = cleanupCallee.AddRange(cleanupCaller);

        var guarded = marshal
            .Add(
                Block(
                    pinnedMarshal.Add(
                        ExpressionStatement(invoke))))
            .AddRange(notify)
            .AddRange(unmarshalCapture)
            .AddRange(unmarshal);
        
        statements = statements.AddRange(setup);

        if (finallyStatements.Any())
        {
            statements = statements.Add(TryStatement()
                .WithBlock(Block(guarded))
                .WithFinally(
                    FinallyClause(
                        Block(finallyStatements)))
            );
        }
        else
        {
            statements = statements.AddRange(guarded);
        }

        if (!ctx.Symbol.ReturnsVoid)
        {
            statements = statements.Add(
                ReturnStatement(
                    IdentifierName("__retVal")));
        }

        return Block(statements);

    }

    private static SyntaxList<TNode> Step<TNode>(
        MethodStubGenerationContext ctx,
        string comment, 
        Func<IParameterSymbol, IMarshallerShape, SyntaxList<TNode>> marshaller,
        SyntaxList<TNode> additional = default) where TNode : SyntaxNode
    {
        var result = List(ctx.Parameters.Where(x => x.MarshallerShape != null)
            .SelectMany(x => marshaller(x.Symbol, x.MarshallerShape)));

        result = result.AddRange(additional);

        if (comment != null && result.Count > 0)
        {
            result = result.Replace(result[0],
                result[0]
                    .WithLeadingTrivia(Comment(comment)));
        }

        return result;
    }
    
    private static LocalDeclarationStatementSyntax CreateLocalDeclarationWithDefaultValue(TypeSyntax type, string identifier) =>
        LocalDeclarationStatement(
            VariableDeclaration(type,
                SingletonSeparatedList(
                    VariableDeclarator(Identifier(identifier))
                        .WithInitializer(
                            EqualsValueClause(
                                LiteralExpression(SyntaxKind.DefaultLiteralExpression, Token(SyntaxKind.DefaultKeyword)))))));

    private static LocalFunctionStatementSyntax CreateExternFunction(MethodStubGenerationContext ctx, TypeSyntax externReturnType)
    {
        var handleParam = Parameter(Identifier("handle_")).WithType(ParseTypeName("nint"));

        var externParameters = ToParameterListSyntax(handleParam, ctx);

        return LocalFunctionStatement(externReturnType, "__PInvoke")
            .WithModifiers(TokenList(          
                Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.UnsafeKeyword),
                Token(SyntaxKind.ExternKeyword)
                ))
            .WithParameterList(externParameters)
            .WithAttributeLists(
                SingletonList(
                    AttributeFactory.DllImport(ctx.Library, ToExternName(ctx))))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .WithLeadingTrivia(Comment("// Local P/Invoke"));
    }

    private static string ToExternName(MethodStubGenerationContext ctx)
    {
        var overload = ctx.Symbol.GetAttribute(Constants.OverloadAttributeFQN)?.ConstructorArguments[0].Value as string;

        return ctx.Symbol.GetAttribute(Constants.FunctionAttributeFQN)?.ConstructorArguments[0].Value is string functionName 
            ? $"{ctx.NativeTypeName}_{functionName}" 
            : $"{ctx.NativeTypeName}_{StringUtil.FirstCharToLower(ctx.Symbol.Name)}{overload}";
    }
    
    private static ParameterListSyntax ToParameterListSyntax(ParameterSyntax first, MethodStubGenerationContext ctx)
    {
        return ParameterList(
            SingletonSeparatedList(first)
                .AddRange(
                    ctx.Parameters
                        .Select(parameter => Parameter(Identifier(parameter.Symbol.Name))
                        .WithType(parameter.MarshallerShape?.GetNativeType() ?? ToTypeSyntax(parameter.Symbol.Type))
                        .WithModifiers(GetRefTokens(parameter.Symbol.RefKind)))));
    }

    private static SyntaxTokenList GetRefTokens(RefKind refKind)
    {
        return refKind switch
        {
            RefKind.Ref => TokenList(Token(SyntaxKind.RefKeyword)),
            RefKind.Out => TokenList(Token(SyntaxKind.OutKeyword)),
            _ => default
        };
    }
    
    private static TypeSyntax ToReturnTypeSyntax(IMethodSymbol symbol)
    {
        return ToTypeSyntax(symbol.ReturnType, symbol.ReturnsByRef || symbol.ReturnsByRefReadonly);
    }

    public static TypeSyntax ToTypeSyntax(ITypeSymbol symbol, bool isRef = false, bool isReadonly = false)
    {
        var result = ParseTypeName(symbol.SpecialType == SpecialType.None 
            ? $"global::{symbol.ToDisplayString()}" 
            : symbol.ToDisplayString());

        if (isRef)
        {
            result = isReadonly 
                ? RefType(result).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)) 
                : RefType(result);
        }
        return result;
    }

    private static ParameterListSyntax ToParameterListSyntax(ImmutableArray<IParameterSymbol> parameters)
    {
        return ParameterList(
            SeparatedList(
                parameters.Select(x => 
                    Parameter(Identifier(x.Name))
                        .WithType(ToTypeSyntax(x.Type))
                        .WithModifiers(GetRefTokens(x.RefKind)))
            )
        );
    }

    private static StructStubGenerationContext GetStructDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (StructDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        var attribute = ctx.Attributes.Single();

        var library = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Library")
            .Value.Value as string ?? "SampSharp";

        var nativeTypeName = attribute.NamedArguments.FirstOrDefault(x => x.Key == "NativeTypeName")
            .Value.Value as string ?? symbol.Name;

        var stringViewMarshaller = ctx.SemanticModel.Compilation.GetTypeByMetadataName("SashManaged.StringViewMarshaller");
        var booleanMarshaller = ctx.SemanticModel.Compilation.GetTypeByMetadataName("SashManaged.BooleanMarshaller");

        var wellKnownMarshallerTypes = new WellKnownMarshallerTypes(
            (x => x.SpecialType == SpecialType.System_String, stringViewMarshaller),
            (x => x.SpecialType == SpecialType.System_Boolean, booleanMarshaller)
        );

        var implementingTypes = attribute.ConstructorArguments[0]
            .Values.Select(x => (ITypeSymbol)x.Value)
            .ToArray();

        // filter methods: partial, non-static, non-generic
        var methods = targetNode.Members.OfType<MethodDeclarationSyntax>()
            .Where(x => x.IsPartial() && !x.HasModifier(SyntaxKind.StaticKeyword) && x.TypeParameterList == null)
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is not { } methodSymbol
                ? (null, null)
                : (methodDeclaration, methodSymbol))
            .Where(x => x.methodSymbol != null)
            .Select(method =>
            {
                var parameters = method.methodSymbol.Parameters.Select(parameter =>
                        new ParameterStubGenerationContext(parameter, MarshallerShapeFactory.GetMarshallerShape(parameter, wellKnownMarshallerTypes)))
                    .ToArray();

                var returnMarshallerShape = MarshallerShapeFactory.GetMarshallerShape(method.methodSymbol, wellKnownMarshallerTypes);
                var requiresMarshalling = returnMarshallerShape != null || parameters.Any(x => x.MarshallerShape != null);

                if (returnMarshallerShape != null && (method.methodSymbol.ReturnsByRef || method.methodSymbol.ReturnsByRefReadonly))
                {
                    // marshalling return-by-ref not supported.
                    // TODO: diagnostic
                    return null;
                }
                return new MethodStubGenerationContext(method.methodDeclaration, method.methodSymbol, parameters, returnMarshallerShape, requiresMarshalling, library, nativeTypeName);
            })
            .Where(x => x != null)
            .ToArray();

        return new StructStubGenerationContext(symbol, targetNode, methods, implementingTypes);
    }
}