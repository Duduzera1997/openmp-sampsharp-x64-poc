using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using System.Xml.Linq;
using System.Reflection.Metadata;

namespace SashManaged.SourceGenerator;

[Generator]
public class OpenMpApiCodeGenV2 : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedStructs = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.ApiAttribute2FQN, 
                static (s, _) => s is StructDeclarationSyntax str && str.IsPartial(), 
                static(ctx, ct) => GetStructDeclaration(ctx, ct))
            .Where(x => x is not null);
        
        context.RegisterSourceOutput(attributedStructs, (ctx, info) =>
        {
            var node = info.Node;
            var symbol = info.Symbol;

            try
            {
                var structDeclaration = StructDeclaration(node.Identifier).WithModifiers(node.Modifiers);

                structDeclaration = structDeclaration.WithMembers(GenerateMembers(info));

                var unit = CompilationUnit()
                    .AddMembers(CreateAutoGeneratedNamespaceDeclaration(symbol.ContainingNamespace)
                        .AddMembers(structDeclaration))
                    .WithLeadingTrivia(
                        // TODO: no nullable? Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
                        Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), CreateList(IdentifierName("CS8500")), true)));

                var sourceText = unit.NormalizeWhitespace(elasticTrivia: true)
                    .GetText(Encoding.UTF8);
                
                ctx.AddSource($"{symbol.Name}.v2.g.cs", sourceText);
            }
            catch(Exception e)
            {
                ctx.AddSource($"{symbol.Name}.v2.g.cs", SourceText.From($"/* ERROR: {e} */", Encoding.UTF8));
                // throw;
            }

        });
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateMembers(StructDeclaration info)
    {
        return new SyntaxList<MemberDeclarationSyntax>()
            .AddRange(GenerateCommonMembers(info))
            .AddRange(info.Methods.Select(GenerateMembers).Where(x => x != null));
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateCommonMembers(StructDeclaration info)
    {
        var nint = ParseTypeName("nint");
        yield return FieldDeclaration(VariableDeclaration(nint, SingletonSeparatedList(VariableDeclarator("_handle"))))
            .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

        yield return ConstructorDeclaration(Identifier(info.Symbol.Name))
            .WithParameterList(ParameterList(
                SingletonSeparatedList(
                Parameter(Identifier("handle")).WithType(nint)
                )))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(
                SingletonList(
                    ExpressionStatement(
                        AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression, 
                            IdentifierName("_handle"),
                            IdentifierName("handle")
                            )
                        )
                    )
                )
            );

        yield return PropertyDeclaration(nint, "Handle")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithExpressionBody(ArrowExpressionClause(IdentifierName("_handle")))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static MemberDeclarationSyntax GenerateMembers((MethodDeclarationSyntax methodDeclaration, IMethodSymbol methodSymbol) info)
    {
        var (node, symbol) = info;

        var returnMarshaller = GetMarshaller(symbol.ReturnType);

        if (returnMarshaller is not NoMarshalling && symbol.ReturnsByRef)
        {
            // cannot ref return a type that needs marshalling
            return null;
        }

        var parameters = symbol.Parameters
            .Select(x => (parameter: x, marshaller: GetParameterMarshaller(x)))
            .ToList();

        var block = CreateMarshallingBlock(symbol, returnMarshaller, parameters);

        var totalBlock = new List<StatementSyntax>();
        
        var requiresUnsafe = returnMarshaller.RequiresUnsafe || 
                             parameters.Any(x => x.marshaller.RequiresUnsafe);

        if (requiresUnsafe && !node.HasModifier(SyntaxKind.UnsafeKeyword))
        {
            var (statement, forwardFunction) = CreateUnsafeForwardMethod(symbol);
            
            totalBlock.Add(statement);
            totalBlock.Add(forwardFunction.WithBody(block));
        }
        else
        {
            totalBlock.AddRange(block.Statements);
        }

        totalBlock.Add(CreateExternMethod(symbol, returnMarshaller, parameters));

        return MethodDeclaration(ToReturnTypeSyntax(symbol), node.Identifier)
            .WithModifiers(node.Modifiers)
            .WithParameterList(ToParameterListSyntax(symbol.Parameters))
            .WithBody(Block(totalBlock));
    }

    private static BlockSyntax CreateMarshallingBlock(IMethodSymbol symbol, 
        IMarshaller returnMarshaller,
        List<(IParameterSymbol parameter, IMarshaller marshaller)> parameters)
    {
        var marshallingRequired = returnMarshaller.RequiresMarshalling || parameters.Any(x => x.marshaller.RequiresMarshalling);

        var statements = new List<StatementSyntax>();

        // TODO: (ref) out marshalling!

        ExpressionSyntax invk = InvocationExpression(IdentifierName("__PInvoke"))
            .WithArgumentList(
                ArgumentList(
                    SingletonSeparatedList(Argument(IdentifierName("_handle")))
                        .AddRange(
                            parameters.Select(x => x.marshaller.GetArgument(x.parameter)
                    )
                )
            )
        );

        StatementSyntax invokeStatement;

        if (!symbol.ReturnsVoid)
        {
            if (symbol.ReturnsByRef || symbol.ReturnsByRefReadonly)
            {
                invk = RefExpression(invk);
            }
            invokeStatement = ReturnStatement(invk);
        }
        else
        {
            invokeStatement = ExpressionStatement(invk);
        }

        if (marshallingRequired)
        {
            foreach (var parameter in parameters)
            {
                statements.AddRange(parameter.marshaller.Setup(parameter.parameter));
            }

            return Block(
                List(parameters.SelectMany(x => x.marshaller.Setup(x.parameter)))// setup
                    .Add(TryStatement()
                        .WithBlock(
                            Block(
                                List(parameters.SelectMany(x => x.marshaller.Marshal(x.parameter))) // marshal
                                    .Add(invokeStatement)
                            )
                        )
                        .WithFinally(FinallyClause(Block(parameters.SelectMany(x => x.marshaller.Free(x.parameter))))) // cleanup
                    )
                );
        }

        return Block(invokeStatement);
    }

    private static (StatementSyntax, LocalFunctionStatementSyntax) CreateUnsafeForwardMethod(IMethodSymbol symbol)
    {
        var arguments = SeparatedList(symbol.Parameters.Select(x =>
        {
            var arg = Argument(IdentifierName(x.Name));

            switch (x.RefKind)
            {
                case RefKind.Ref:
                    arg = arg.WithRefKindKeyword(Token(SyntaxKind.RefKeyword));
                    break;
                case RefKind.Out:
                    arg = arg.WithRefKindKeyword(Token(SyntaxKind.OutKeyword));
                    break;
            }

            return arg;
        }));

        var forwardMethod = LocalFunctionStatement(ToReturnTypeSyntax(symbol), "__Forward")
            .WithParameterList(ToParameterListSyntax(symbol.Parameters))
            .WithModifiers(TokenList(Token(SyntaxKind.UnsafeKeyword)));
        
        var call = InvocationExpression(IdentifierName("__Forward"))
            .WithArgumentList(ArgumentList(arguments));

        StatementSyntax statement;
        if (symbol.ReturnsVoid)
        {
            statement = ExpressionStatement(call);
        }
        else if (symbol.ReturnsByRef)
        {
            statement = ReturnStatement(RefExpression(call));
        }
        else
        {
            statement = ReturnStatement(call);
        }

        return (statement, forwardMethod);
    }

    private static LocalFunctionStatementSyntax CreateExternMethod(IMethodSymbol symbol, 
        IMarshaller returnMarshaller, 
        IEnumerable<(IParameterSymbol parameter, IMarshaller marshaller)> parameterMarshallers)
    {
        var externReturnType = returnMarshaller.GetExternalType(symbol.ReturnType);

        if (symbol.ReturnsByRef || symbol.ReturnsByRefReadonly)
        {
            externReturnType = symbol.ReturnsByRefReadonly 
                ? RefType(externReturnType).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)) 
                : RefType(externReturnType);
        }

        var cdecl = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression, 
            ParseTypeName("System.Runtime.InteropServices.CallingConvention"), 
            IdentifierName("Cdecl"));
        
        var handleParam = Parameter(Identifier("handle_")).WithType(ParseTypeName("nint"));

        var externParameters = ToParameterListSyntax(handleParam, parameterMarshallers);

        return LocalFunctionStatement(externReturnType, "__PInvoke")
            .WithModifiers(TokenList(          
                Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.UnsafeKeyword),
                Token(SyntaxKind.ExternKeyword)
                ))
            .WithParameterList(externParameters)
            .WithAttributeLists(
                SingletonList(
                    AttributeList(
                        SeparatedList(new[]
                        {
                            Attribute(ParseName("global::System.Runtime.InteropServices.DllImportAttribute"),
                                AttributeArgumentList(
                                    SeparatedList(new[] {
                                        AttributeArgument(
                                            LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("SampSharp"))
                                        ),
                                        AttributeArgument(cdecl)
                                            .WithNameEquals(NameEquals("CallingConvention")),
                                        AttributeArgument(
                                                LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(ToExternName(symbol)))
                                            )
                                            .WithNameEquals(NameEquals("EntryPoint")),
                                        AttributeArgument(
                                                LiteralExpression(SyntaxKind.TrueLiteralExpression)
                                            )
                                            .WithNameEquals(NameEquals("ExactSpelling"))
                                    })
                                )
                            )
                        })
                    )
                )
            )
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .WithTrailingTrivia(ElasticCarriageReturnLineFeed);
    }

    private static string ToExternName(IMethodSymbol symbol)
    {
        var type = symbol.ContainingType;

        var overload = symbol.GetAttributes(Constants.OverloadAttributeFQN).FirstOrDefault()?.ConstructorArguments[0].Value as string;
        var functionName = symbol.GetAttributes(Constants.FunctionAttributeFQN).FirstOrDefault()?.ConstructorArguments[0].Value as string;

        if (functionName != null)
        {
            return $"{type.Name}_{functionName}";
        }

        return $"{type.Name}_{FirstLower(symbol.Name)}{overload}";
    }
    
    private static string FirstLower(string value)
    {
        return $"{char.ToLowerInvariant(value[0])}{value.Substring(1)}";
    }

    private static IMarshaller GetMarshaller(ITypeSymbol typeSyntax)
    {
        switch (typeSyntax.SpecialType)
        {
            case SpecialType.System_Boolean:
                return BooleanMarshalling.Instance;
            case SpecialType.System_String:
                return StringMarshalling.Instance;
        }

        if (typeSyntax.SpecialType != SpecialType.None)
        {
            return NoMarshalling.Instance;
        }

        // TODO: check for type marshalling attributes
        return NoMarshalling.Instance;
    }
    
    private static IMarshaller GetParameterMarshaller(IParameterSymbol parameterSymbol)
    {
        return GetMarshaller(parameterSymbol.Type);
    }
    
    public class BooleanMarshalling : Marshaller
    {
        public static BooleanMarshalling Instance { get; } = new();

        public override bool RequiresMarshalling => false;
        public override bool RequiresUnsafe => false;

        public override TypeSyntax GetExternalType(ITypeSymbol typeSymbol)
        {
            return ParseTypeName($"global::{Constants.BlittableBooleanFQN}");
        }
    }

    public class StringMarshalling : Marshaller
    {
        public static StringMarshalling Instance { get; } = new();

        public override bool RequiresMarshalling => true;
        public override bool RequiresUnsafe => false;

        public override TypeSyntax GetExternalType(ITypeSymbol typeSymbol)
        {
            return ParseTypeName($"global::{Constants.StringViewFQN}");
        }

        public override SyntaxList<StatementSyntax> Setup(IParameterSymbol parameter)
        {
            // TODO to const
            var marshallerType = ParseTypeName("global::SashManaged.StringViewMarshaller.ManagedToUnmanagedIn");

            return List(new StatementSyntax[]{
                LocalDeclarationStatement(
                    VariableDeclaration(
                        ParseTypeName($"global::{Constants.StringViewFQN}"), 
                        SingletonSeparatedList(
                            VariableDeclarator(Identifier($"__{parameter.Name}_native"))
                                .WithInitializer(
                                    EqualsValueClause(
                                        LiteralExpression(SyntaxKind.DefaultLiteralExpression, Token(SyntaxKind.DefaultKeyword))
                                    )
                                )
                        )
                    )
                ),
                LocalDeclarationStatement(
                    VariableDeclaration(
                        marshallerType, 
                        SingletonSeparatedList(
                            VariableDeclarator(Identifier($"__{parameter.Name}_native_marshaller"))
                                .WithInitializer(
                                    EqualsValueClause(
                                        ImplicitObjectCreationExpression()
                                    )
                                )
                        )
                    )
                )
                    .WithModifiers(TokenList(Token(SyntaxKind.ScopedKeyword))),
            });
        }

        public override SyntaxList<StatementSyntax> Marshal(IParameterSymbol parameter)
        {
            var marshallerType = ParseTypeName("global::SashManaged.StringViewMarshaller.ManagedToUnmanagedIn");
            
            var stackAlloc = StackAllocArrayCreationExpression(
                ArrayType(
                        PredefinedType(Token(SyntaxKind.ByteKeyword)))
                    .WithRankSpecifiers(
                        SingletonList(
                            ArrayRankSpecifier(
                                SingletonSeparatedList<ExpressionSyntax>(
                                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, marshallerType, IdentifierName("BufferSize"))
                                )
                            )
                        )
                    )
                );
            return List(new StatementSyntax[]
            {
                ExpressionStatement(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression, 
                            IdentifierName($"__{parameter.Name}_native_marshaller"),
                            IdentifierName("FromManaged")
                        )
                    )
                        .WithArgumentList(
                            ArgumentList(
                                    SeparatedList(new[]{
                                        Argument(IdentifierName(parameter.Name)),
                                        Argument(stackAlloc)
                                    })
                                )
                            )
                ),
                ExpressionStatement(
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        IdentifierName($"__{parameter.Name}_native"),
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression, 
                                IdentifierName($"__{parameter.Name}_native_marshaller"),
                                IdentifierName("ToUnmanaged")
                                )
                            )
                        )
                    )
            });
        }

        public override SyntaxList<StatementSyntax> Free(IParameterSymbol parameter)
        {
            return List(new StatementSyntax[]
            {
                ExpressionStatement(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression, 
                            IdentifierName($"__{parameter.Name}_native_marshaller"),
                            IdentifierName("Free")
                            )
                        )
                    )
            });
        }
        
        public override ArgumentSyntax GetArgument(IParameterSymbol parameter)
        {
            return WithParameterRefKind(Argument(IdentifierName($"__{parameter.Name}_native")), parameter);
        }
    }

    public class NoMarshalling : Marshaller
    {
        public static NoMarshalling Instance { get; } = new();
        public override bool RequiresMarshalling => false;
        public override bool RequiresUnsafe => false;

        public override TypeSyntax GetExternalType(ITypeSymbol typeSymbol)
        {
            return ToTypeSyntax(typeSymbol);
        }
    }
    
    public abstract class Marshaller : IMarshaller
    {
        public abstract bool RequiresMarshalling { get; }
        public abstract bool RequiresUnsafe { get; }
        public abstract TypeSyntax GetExternalType(ITypeSymbol typeSymbol);
        public virtual SyntaxList<StatementSyntax> Setup(IParameterSymbol parameter)
        {
            return List<StatementSyntax>();
        }

        public virtual SyntaxList<StatementSyntax> Marshal(IParameterSymbol parameter)
        {
            return List<StatementSyntax>();
        }

        public virtual SyntaxList<StatementSyntax> Free(IParameterSymbol parameter)
        {
            return List<StatementSyntax>();
        }

        public virtual ArgumentSyntax GetArgument(IParameterSymbol parameter)
        {
            return WithParameterRefKind(Argument(IdentifierName(parameter.Name)), parameter);
        }

        protected ArgumentSyntax WithParameterRefKind(ArgumentSyntax argument, IParameterSymbol parameter)
        {
            switch (parameter.RefKind)
            {
                case RefKind.Ref:
                    return argument.WithRefKindKeyword(Token(SyntaxKind.RefKeyword));
                case RefKind.Out:
                    return argument.WithRefKindKeyword(Token(SyntaxKind.OutKeyword));
                default:
                    return argument;
            }
        }
    }

    public interface IMarshaller
    {
        bool RequiresMarshalling { get; }
        bool RequiresUnsafe { get; }
        TypeSyntax GetExternalType(ITypeSymbol typeSymbol);
        SyntaxList<StatementSyntax> Setup(IParameterSymbol parameter);
        SyntaxList<StatementSyntax> Marshal(IParameterSymbol parameter);
        SyntaxList<StatementSyntax> Free(IParameterSymbol parameter);
        ArgumentSyntax GetArgument(IParameterSymbol parameter);
    }
    
    private static ParameterListSyntax ToParameterListSyntax(ImmutableArray<IParameterSymbol> parameters)
    {
        return ParameterList(
            SeparatedList(
                parameters.Select(x => 
                    Parameter(Identifier(x.Name))
                        .WithType(ToTypeSyntax(x.Type))
                        .WithModifiers(GetRefTokens(x.RefKind)))
                )
            );
    }

    private static ParameterListSyntax ToParameterListSyntax(ParameterSyntax first, IEnumerable<(IParameterSymbol symbol, IMarshaller marshaller)> parameters)
    {
        var result = new List<ParameterSyntax>
        {
            first
        };

        foreach (var parameter in parameters)
        {
            result.Add(Parameter(Identifier(parameter.symbol.Name))
                .WithType(parameter.marshaller.GetExternalType(parameter.symbol.Type))
                .WithModifiers(GetRefTokens(parameter.symbol.RefKind)));
        }

        return ParameterList(new SeparatedSyntaxList<ParameterSyntax>().AddRange(result));
    }

    private static SyntaxTokenList GetRefTokens(RefKind refKind)
    {
        return refKind switch
        {
            RefKind.Ref => TokenList(Token(SyntaxKind.RefKeyword)),
            RefKind.Out => TokenList(Token(SyntaxKind.OutKeyword)),
            _ => default
        };
    }
    
    private static TypeSyntax ToReturnTypeSyntax(IMethodSymbol symbol)
    {
        return ToTypeSyntax(symbol.ReturnType, symbol.ReturnsByRef || symbol.ReturnsByRefReadonly);
    }

    private static TypeSyntax ToTypeSyntax(ITypeSymbol symbol, bool isRef = false, bool isReadonly = false)
    {
        var result = ParseTypeName(symbol.SpecialType == SpecialType.None 
            ? $"global::{symbol.ToDisplayString()}" 
            : symbol.ToDisplayString());

        if (isRef)
        {
            result = isReadonly 
                ? RefType(result).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)) 
                : RefType(result);
        }
        return result;
    }

    private static SeparatedSyntaxList<ExpressionSyntax> CreateList(params ExpressionSyntax[] values)
    {
        return new SeparatedSyntaxList<ExpressionSyntax>().AddRange(values);
    }

    private static NamespaceDeclarationSyntax CreateAutoGeneratedNamespaceDeclaration(INamespaceSymbol ns)
    {
        var trivia = Token(TriviaList(Comment("// <auto-generated />")), SyntaxKind.NamespaceKeyword, TriviaList());
        return NamespaceDeclaration(ParseName(ns.ToDisplayString())).WithNamespaceKeyword(trivia);
    }

    private static StructDeclaration GetStructDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (StructDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;
        
        // partial, non-static, non-generic
        List<(MethodDeclarationSyntax, IMethodSymbol)> methods = targetNode.Members.OfType<MethodDeclarationSyntax>()
            .Where(x => x.IsPartial() && !x.HasModifier(SyntaxKind.StaticKeyword) && x.TypeParameterList == null)
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is not { } methodSymbol 
                ? (null, null)
                : (methodDeclaration, methodSymbol))
            .Where(x => x.methodSymbol != null)
            .ToList();

        return new StructDeclaration(symbol, targetNode, methods);
    }

    private record StructDeclaration(
        ISymbol Symbol,
        StructDeclarationSyntax Node,
        List<(MethodDeclarationSyntax node, IMethodSymbol symbol)> Methods);
}