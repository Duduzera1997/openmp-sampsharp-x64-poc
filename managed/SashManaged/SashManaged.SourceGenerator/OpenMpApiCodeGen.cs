using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using CSharpExtensions = Microsoft.CodeAnalysis.CSharpExtensions;

namespace SashManaged.SourceGenerator;

[Generator]
public class OpenMpApiCodeGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var structPovider = context.SyntaxProvider
            .CreateSyntaxProvider(predicate: IsPartialStruct, transform: GetStructDeclaration)
            .WithTrackingName("Syntax");

        context.RegisterSourceOutput(structPovider, (ctx, node) =>
        {
            if (node == null)
            {
                return;
            }

            ctx.AddSource(node.Symbol.Name + ".g.cs", SourceText.From(Process(node), Encoding.UTF8));
        });
    }

    private static string Process(StructDecl node)
    {
        // TODO: inheritance
        var sb = new StringBuilder();

        sb.AppendLine($$"""
                        /// <auto-generated />

                        namespace {{node.Symbol.ContainingNamespace.ToDisplayString()}}
                        {
                            {{Constants.SequentialStructLayoutAttribute}}
                            {{node.TypeDeclaration.Modifiers}} struct {{node.Symbol.Name}}
                            {
                                private readonly nint _data;
                                
                        """);

        foreach (var member in node.TypeDeclaration.Members)
        {
            if (member is not MethodDeclarationSyntax memberDeclaration || 
                !member.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
            {
                continue;
            }

            var methodName = memberDeclaration.Identifier.ToString();
            var proxyName = $"{node.Symbol.Name}_{FirstLower(methodName)}";

            var methodSymbols = node.Members.Where(x => x.Name == methodName).ToList();
            if (methodSymbols.Count != 1)
            {
                continue;
            }
            var methodSymbol = methodSymbols.First();
            
            var returnType = methodSymbol.ReturnType.ToDisplayString();
            var returnTypeNative = returnType;
            var isVoidReturn = methodSymbol.ReturnsVoid;
            var isUnsafe = memberDeclaration.Modifiers.Any(x => x.IsKind(SyntaxKind.UnsafeKeyword));
            
            var requiresReturnMarshalling = !methodSymbol.ReturnsVoid && methodSymbol.GetReturnTypeAttributes().HasAttribute("SashManaged.MarshallAttribute");
            var requiresMarshalling = methodSymbol.Parameters.Any(x => x.HasAttribute("SashManaged.MarshallAttribute"));
            var requiresUnsafeWrapper = methodSymbol.ReturnsByRef || requiresMarshalling || requiresReturnMarshalling;

            var parametersString = Common.ParameterAsString(methodSymbol.Parameters);
            var parametersStringMarshalled = Common.ParameterAsString(methodSymbol.Parameters, requiresMarshalling);

            if (methodSymbol.ReturnType is INamedTypeSymbol
                {
                    IsGenericType: true
                } returnTypeSymbol)
            {
                var genDisplay = returnTypeSymbol.OriginalDefinition.ToDisplayString();

                if (genDisplay == "SashManaged.OpenMp.IEventDispatcher<T>")
                {
                    var handlerType = returnTypeSymbol.TypeArguments[0];
                    var handlerName = handlerType.Name.Substring(1);
                    var handlerNamespace = handlerType.ContainingNamespace.ToDisplayString();
                    returnTypeNative = $"{handlerNamespace}.IEventDispatcher_{handlerName}";
                }
            }

            if (requiresReturnMarshalling)
            {
                returnTypeNative = "nint";
            }

            // extern
            sb.Append($$"""
                                {{Common.DllImportAttribute("SampSharp")}}
                                private static {{(methodSymbol.ReturnsByRef || isUnsafe ? "unsafe " : "")}}extern {{returnTypeNative}}{{(methodSymbol.ReturnsByRef ? "*" : "")}} {{proxyName}}({{node.Symbol.Name}} ptr
                        """);

            if (memberDeclaration.ParameterList.Parameters.Count > 0)
            {
                sb.Append($", {parametersStringMarshalled}");
            }

            sb.AppendLine(");");
            sb.AppendLine();
                           ;

            if (requiresUnsafeWrapper)
            {
                var refModifier = methodSymbol.ReturnsByRef ? "ref " : "";
                // unsafe wrapper
                sb.AppendLine($$"""
                                    private unsafe {{refModifier}}{{returnType}} {{methodName}}_unsafe({{parametersString}})
                                    {
                                        
                            """);

                // marshalling
                foreach (var parameter in methodSymbol.Parameters)
                {
                    if (parameter.HasAttribute("SashManaged.MarshallAttribute"))
                    {
                        sb.AppendLine($$"""
                                        var {{parameter.Name}}_ = System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Runtime.InteropServices.Marshal.SizeOf(typeof({{parameter.Type.ToDisplayString()}})));
                                        System.Runtime.InteropServices.Marshal.StructureToPtr({{parameter.Name}}, {{parameter.Name}}_, true);
                            """);
                    }
                }
                
                if (requiresMarshalling)
                {
                    sb.AppendLine("""
                                              try
                                              {
                                  """);
                }

                // call to extern
                sb.Append($"                {(methodSymbol.ReturnsVoid ? "" : "var returnValue = ")}{proxyName}(this");

                if (memberDeclaration.ParameterList.Parameters.Count > 0)
                {
                    sb.Append(", ");

                    sb.Append(Common.GetForwardArguments(methodSymbol, requiresMarshalling));
                }

                sb.AppendLine(");");

                if (methodSymbol.ReturnsByRef)
                {
                    sb.AppendLine("            if(returnValue == null) throw new System.NullReferenceException(\"Result is null.\");");
                    sb.AppendLine("            return ref *returnValue;");
                }
                else if (requiresReturnMarshalling)
                {
                    
                    sb.AppendLine($"            return System.Runtime.InteropServices.Marshal.PtrToStructure<{methodSymbol.ReturnType.ToDisplayString()}>(returnValue);");
                }
                else if (!methodSymbol.ReturnsVoid)
                {
                    sb.AppendLine("            return returnValue;");
                }


                if (requiresMarshalling)
                {
                    // free alloc by marshall
                    sb.AppendLine("""
                                        }
                                        finally
                                        {
                            """);

                    foreach (var parameter in methodSymbol.Parameters)
                    {
                        if (parameter.HasAttribute("SashManaged.MarshallAttribute"))
                        {
                            sb.AppendLine($$"""
                                                    System.Runtime.InteropServices.Marshal.FreeHGlobal({{parameter.Name}}_);
                                    """);
                        }
                    }

                    sb.AppendLine("""
                                            }
                                """);
                }

                sb.AppendLine("        }");
                sb.AppendLine();
                
                sb.AppendLine($$"""
                                    {{member.Modifiers}} {{refModifier}}{{returnType}} {{methodName}}({{parametersString}})
                                    {
                                        {{(methodSymbol.ReturnsVoid ? "" : "return ")}}{{refModifier}}{{methodName}}_unsafe({{Common.GetForwardArguments(methodSymbol)}});
                                    }
                                    
                            """);
            }
            else
            {
                // method declaration
                sb.Append($$"""
                                    {{member.Modifiers}} {{returnType}} {{methodName}}({{parametersString}})
                                    {
                                        
                            """);

                // call to extern
                if (!isVoidReturn)
                {
                    sb.Append($"return ");
                }

                sb.Append($"{proxyName}(this");

                if (memberDeclaration.ParameterList.Parameters.Count > 0)
                {
                    sb.Append(", ");

                    sb.Append(Common.GetForwardArguments(methodSymbol));
                }

                sb.AppendLine(");");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
        }

        sb.Append("""
                      }
                  }
                  """);

        return sb.ToString();
    }

 
    private static string FirstLower(string value)
    {
        return $"{char.ToLowerInvariant(value[0])}{value.Substring(1)}";
    }
        
    private static bool IsPartialStruct(SyntaxNode syntax, CancellationToken _)
    {
        return syntax is StructDeclarationSyntax
        {
            AttributeLists.Count: > 0
        } structDecl && structDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static StructDecl GetStructDeclaration(GeneratorSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var declaration = (StructDeclarationSyntax)ctx.Node;
        if (ctx.SemanticModel.GetDeclaredSymbol(declaration, cancellationToken) is not { } symbol)
            return null;
            
        if (!symbol.HasAttribute("SashManaged.OpenMpApiAttribute"))
            return null;

        var members = symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.IsPartialDefinition)
            .ToList();

        return new StructDecl(symbol, declaration, members);
    }

    private class StructDecl(ISymbol symbol, StructDeclarationSyntax typeDeclaration, List<IMethodSymbol> members)
    {
        public ISymbol Symbol { get; } = symbol;
        public StructDeclarationSyntax TypeDeclaration { get; } = typeDeclaration;
        public List<IMethodSymbol> Members { get; } = members;
    }
}