using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SashManaged.SourceGenerator.Marshalling;

namespace SashManaged.SourceGenerator;

[Generator]
public class OpenMpApiCodeGenV2 : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedStructs = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.ApiAttribute2FQN, 
                static (s, _) => s is StructDeclarationSyntax str && str.IsPartial(), 
                static(ctx, ct) => GetStructDeclaration(ctx, ct))
            .Where(x => x is not null);
        
        context.RegisterSourceOutput(attributedStructs, (ctx, info) =>
        {
            var node = info.Node;
            var symbol = info.Symbol;

            var structDeclaration = StructDeclaration(node.Identifier)
                .WithModifiers(node.Modifiers)
                .WithMembers(GenerateMembers(info));

            var unit = CompilationUnit()
                .AddMembers(CreateAutoGeneratedNamespaceDeclaration(symbol.ContainingNamespace)
                    .AddMembers(structDeclaration))
                .WithLeadingTrivia(
                    Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), CreateList(IdentifierName("CS8500")), true)));

            var sourceText = unit.NormalizeWhitespace(elasticTrivia: true)
                .GetText(Encoding.UTF8);
            
            ctx.AddSource($"{symbol.Name}.v2.g.cs", sourceText);
        });
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateMembers(StructDeclaration info)
    {

        return List(
            GenerateCommonMembers(info)
                .Concat(
                    info.Methods.Select(GenerateMembers)
                        .Where(x => x != null)
                )
            );
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateCommonMembers(StructDeclaration info)
    {
        var nint = ParseTypeName("nint");
        yield return FieldDeclaration(VariableDeclaration(nint, SingletonSeparatedList(VariableDeclarator("_handle"))))
            .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

        yield return ConstructorDeclaration(Identifier(info.Symbol.Name))
            .WithParameterList(ParameterList(
                SingletonSeparatedList(
                Parameter(Identifier("handle")).WithType(nint)
                )))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(
                SingletonList(
                    ExpressionStatement(
                        AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression, 
                            IdentifierName("_handle"),
                            IdentifierName("handle")
                            )
                        )
                    )
                )
            );

        yield return PropertyDeclaration(nint, "Handle")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithExpressionBody(ArrowExpressionClause(IdentifierName("_handle")))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static MemberDeclarationSyntax GenerateMembers((MethodDeclarationSyntax methodDeclaration, IMethodSymbol methodSymbol) info)
    {
        var (node, symbol) = info;

        var returnMarshaller = GetMarshaller(symbol.ReturnType);

        if (returnMarshaller is not NoOpMarshaller && symbol.ReturnsByRef)
        {
            // cannot ref return a type that needs marshalling
            return null;
        }

        var parameters = symbol.Parameters
            .Select(x => (parameter: x, marshaller: GetParameterMarshaller(x)))
            .ToList();

        var block = CreateMarshallingBlock(symbol, returnMarshaller, parameters);

        var totalBlock = new List<StatementSyntax>();
        
        var requiresUnsafe = returnMarshaller.RequiresUnsafe || 
                             parameters.Any(x => x.marshaller.RequiresUnsafe);

        if (requiresUnsafe && !node.HasModifier(SyntaxKind.UnsafeKeyword))
        {
            var (statement, forwardFunction) = CreateUnsafeForwardMethod(symbol);
            
            totalBlock.Add(statement);
            totalBlock.Add(forwardFunction.WithBody(block));
        }
        else
        {
            totalBlock.AddRange(block.Statements);
        }

        totalBlock.Add(CreateExternMethod(symbol, returnMarshaller, parameters));

        return MethodDeclaration(ToReturnTypeSyntax(symbol), node.Identifier)
            .WithModifiers(node.Modifiers)
            .WithParameterList(ToParameterListSyntax(symbol.Parameters))
            .WithBody(Block(totalBlock));
    }

    private static BlockSyntax CreateMarshallingBlock(IMethodSymbol symbol, 
        IMarshaller returnMarshaller,
        List<(IParameterSymbol parameter, IMarshaller marshaller)> parameters)
    {
        var marshallingRequired = returnMarshaller.RequiresMarshalling || parameters.Any(x => x.marshaller.RequiresMarshalling);

        // TODO: marshal result of ref?
        ExpressionSyntax expression = InvocationExpression(IdentifierName("__PInvoke"))
            .WithArgumentList(
                ArgumentList(
                    SingletonSeparatedList(Argument(IdentifierName("_handle")))
                        .AddRange(
                            parameters.Select(x => x.marshaller.GetArgument(x.parameter)
                    )
                )
            )
        );

        expression = returnMarshaller.UnmanagedToManaged(expression);
        StatementSyntax invokeStatement;

        if (!symbol.ReturnsVoid)
        {
            if (symbol.ReturnsByRef || symbol.ReturnsByRefReadonly)
            {
                expression = RefExpression(expression);
            }
            invokeStatement = ReturnStatement(expression);
        }
        else
        {
            invokeStatement = ExpressionStatement(expression);
        }

        if (marshallingRequired)
        {
            return Block(
                List(parameters.SelectMany(x => x.marshaller.Setup(x.parameter)))// setup
                    .Add(TryStatement()
                        .WithBlock(
                            Block(
                                List(parameters.SelectMany(x => x.marshaller.ManagedToUnmanaged(x.parameter))) // marshal
                                    .Add(invokeStatement)
                            )
                        )
                        .WithFinally(FinallyClause(Block(parameters.SelectMany(x => x.marshaller.Free(x.parameter))))) // cleanup
                    )
                );
        }

        return Block(invokeStatement);
    }

    private static (StatementSyntax, LocalFunctionStatementSyntax) CreateUnsafeForwardMethod(IMethodSymbol symbol)
    {
        var arguments = SeparatedList(symbol.Parameters.Select(x =>
        {
            var arg = Argument(IdentifierName(x.Name));

            switch (x.RefKind)
            {
                case RefKind.Ref:
                    arg = arg.WithRefKindKeyword(Token(SyntaxKind.RefKeyword));
                    break;
                case RefKind.Out:
                    arg = arg.WithRefKindKeyword(Token(SyntaxKind.OutKeyword));
                    break;
            }

            return arg;
        }));

        var forwardMethod = LocalFunctionStatement(ToReturnTypeSyntax(symbol), "__Forward")
            .WithParameterList(ToParameterListSyntax(symbol.Parameters))
            .WithModifiers(TokenList(Token(SyntaxKind.UnsafeKeyword)));
        
        var call = InvocationExpression(IdentifierName("__Forward"))
            .WithArgumentList(ArgumentList(arguments));

        StatementSyntax statement;
        if (symbol.ReturnsVoid)
        {
            statement = ExpressionStatement(call);
        }
        else if (symbol.ReturnsByRef)
        {
            statement = ReturnStatement(RefExpression(call));
        }
        else
        {
            statement = ReturnStatement(call);
        }

        return (statement, forwardMethod);
    }

    private static LocalFunctionStatementSyntax CreateExternMethod(IMethodSymbol symbol, 
        IMarshaller returnMarshaller, 
        IEnumerable<(IParameterSymbol parameter, IMarshaller marshaller)> parameterMarshallers)
    {
        var externReturnType = returnMarshaller.GetExternalType(symbol.ReturnType);

        if (symbol.ReturnsByRef || symbol.ReturnsByRefReadonly)
        {
            externReturnType = symbol.ReturnsByRefReadonly 
                ? RefType(externReturnType).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)) 
                : RefType(externReturnType);
        }

        var cdecl = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression, 
            ParseTypeName("System.Runtime.InteropServices.CallingConvention"), 
            IdentifierName("Cdecl"));
        
        var handleParam = Parameter(Identifier("handle_")).WithType(ParseTypeName("nint"));

        var externParameters = ToParameterListSyntax(handleParam, parameterMarshallers);

        return LocalFunctionStatement(externReturnType, "__PInvoke")
            .WithModifiers(TokenList(          
                Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.UnsafeKeyword),
                Token(SyntaxKind.ExternKeyword)
                ))
            .WithParameterList(externParameters)
            .WithAttributeLists(
                SingletonList(
                    AttributeList(
                        SeparatedList(new[]
                        {
                            Attribute(ParseName("global::System.Runtime.InteropServices.DllImportAttribute"),
                                AttributeArgumentList(
                                    SeparatedList(new[] {
                                        AttributeArgument(
                                            LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("SampSharp"))
                                        ),
                                        AttributeArgument(cdecl)
                                            .WithNameEquals(NameEquals("CallingConvention")),
                                        AttributeArgument(
                                                LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(ToExternName(symbol)))
                                            )
                                            .WithNameEquals(NameEquals("EntryPoint")),
                                        AttributeArgument(
                                                LiteralExpression(SyntaxKind.TrueLiteralExpression)
                                            )
                                            .WithNameEquals(NameEquals("ExactSpelling"))
                                    })
                                )
                            )
                        })
                    )
                )
            )
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .WithTrailingTrivia(ElasticCarriageReturnLineFeed);
    }

    private static string ToExternName(IMethodSymbol symbol)
    {
        var type = symbol.ContainingType;

        var overload = symbol.GetAttributes(Constants.OverloadAttributeFQN).FirstOrDefault()?.ConstructorArguments[0].Value as string;
        var functionName = symbol.GetAttributes(Constants.FunctionAttributeFQN).FirstOrDefault()?.ConstructorArguments[0].Value as string;

        if (functionName != null)
        {
            return $"{type.Name}_{functionName}";
        }

        return $"{type.Name}_{FirstLower(symbol.Name)}{overload}";
    }
    
    private static string FirstLower(string value)
    {
        return $"{char.ToLowerInvariant(value[0])}{value.Substring(1)}";
    }

    private static IMarshaller GetMarshaller(ITypeSymbol typeSyntax)
    {
        switch (typeSyntax.SpecialType)
        {
            case SpecialType.System_Boolean:
                return BooleanMarshalling.Instance;
            case SpecialType.System_String:
                return StringMarshalling.Instance;
        }

        if (typeSyntax.SpecialType != SpecialType.None)
        {
            return NoOpMarshaller.Instance;
        }

        // TODO: check for type marshalling attributes
        return NoOpMarshaller.Instance;
    }
    
    private static IMarshaller GetParameterMarshaller(IParameterSymbol parameterSymbol)
    {
        return GetMarshaller(parameterSymbol.Type);
    }
    
    private static ParameterListSyntax ToParameterListSyntax(ParameterSyntax first, IEnumerable<(IParameterSymbol symbol, IMarshaller marshaller)> parameters)
    {
        var result = new List<ParameterSyntax>
        {
            first
        };

        foreach (var parameter in parameters)
        {
            result.Add(Parameter(Identifier(parameter.symbol.Name))
                .WithType(parameter.marshaller.GetExternalType(parameter.symbol.Type))
                .WithModifiers(GetRefTokens(parameter.symbol.RefKind)));
        }

        return ParameterList(new SeparatedSyntaxList<ParameterSyntax>().AddRange(result));
    }

    private static SyntaxTokenList GetRefTokens(RefKind refKind)
    {
        return refKind switch
        {
            RefKind.Ref => TokenList(Token(SyntaxKind.RefKeyword)),
            RefKind.Out => TokenList(Token(SyntaxKind.OutKeyword)),
            _ => default
        };
    }
    
    private static TypeSyntax ToReturnTypeSyntax(IMethodSymbol symbol)
    {
        return ToTypeSyntax(symbol.ReturnType, symbol.ReturnsByRef || symbol.ReturnsByRefReadonly);
    }

    public static TypeSyntax ToTypeSyntax(ITypeSymbol symbol, bool isRef = false, bool isReadonly = false)
    {
        var result = ParseTypeName(symbol.SpecialType == SpecialType.None 
            ? $"global::{symbol.ToDisplayString()}" 
            : symbol.ToDisplayString());

        if (isRef)
        {
            result = isReadonly 
                ? RefType(result).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)) 
                : RefType(result);
        }
        return result;
    }

    private static SeparatedSyntaxList<ExpressionSyntax> CreateList(params ExpressionSyntax[] values)
    {
        return new SeparatedSyntaxList<ExpressionSyntax>().AddRange(values);
    }

    private static NamespaceDeclarationSyntax CreateAutoGeneratedNamespaceDeclaration(INamespaceSymbol ns)
    {
        var trivia = Token(TriviaList(Comment("// <auto-generated />")), SyntaxKind.NamespaceKeyword, TriviaList());
        return NamespaceDeclaration(ParseName(ns.ToDisplayString())).WithNamespaceKeyword(trivia);
    }
    
    private static ParameterListSyntax ToParameterListSyntax(ImmutableArray<IParameterSymbol> parameters)
    {
        return ParameterList(
            SeparatedList(
                parameters.Select(x => 
                    Parameter(Identifier(x.Name))
                        .WithType(ToTypeSyntax(x.Type))
                        .WithModifiers(GetRefTokens(x.RefKind)))
            )
        );
    }

    private static StructDeclaration GetStructDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (StructDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;
        
        // partial, non-static, non-generic
        List<(MethodDeclarationSyntax, IMethodSymbol)> methods = targetNode.Members.OfType<MethodDeclarationSyntax>()
            .Where(x => x.IsPartial() && !x.HasModifier(SyntaxKind.StaticKeyword) && x.TypeParameterList == null)
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is not { } methodSymbol 
                ? (null, null)
                : (methodDeclaration, methodSymbol))
            .Where(x => x.methodSymbol != null)
            .ToList();

        return new StructDeclaration(symbol, targetNode, methods);
    }

    private record StructDeclaration(
        ISymbol Symbol,
        StructDeclarationSyntax Node,
        List<(MethodDeclarationSyntax node, IMethodSymbol symbol)> Methods);
}